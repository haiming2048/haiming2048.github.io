{"meta":{"title":"Haiming","subtitle":"Hacker inside","description":"description....","author":"Haiming","url":"http://haiming2048.github.io","root":"/"},"pages":[],"posts":[{"title":"A/B Testing Part II","slug":"AB-Testing-2","date":"2020-07-28T20:12:30.000Z","updated":"2020-07-28T21:02:15.431Z","comments":true,"path":"en/AB-Testing-2/","link":"","permalink":"http://haiming2048.github.io/en/AB-Testing-2/","excerpt":"","text":"This is the second part of AB Testing, if you haven’t read the first part (A/B Testing Part I), it bettle to read it first, then come back latter. In the first part, We summarized the 5 steps to do AB Testing, and in this blog, we will introduce more key principles and insights about AB Testing. 1. Seek the Global Maximum – Refinement and Exploration Incrementalism can lead to local maxima. Be willing to explore to find the big wins before testing smaller changes and tweaks. Conversely, sometimes it’s the incremental refinements that prove or disprove your hypotheses about what your users respond to. Use the insights from small tests to guide and inform your thinking about bigger changes. Consider entirely new alternative approaches to your principal business goals. Be willing to go beyond just testing “variations on a theme”—you might be surprised. If you’re working on a major site redesign or overhaul, don’t wait until the new design is live to A/B test it. A/B test the redesign itself. 2. Less Is More: Reduce Choices – When Subtraction Adds Value More technologically or visually impressive pages don’t necessarily lead to the user behavior you want. Experiment with keeping it simple and make any additional complex- ity earn its keep in your key success metrics. Every form field that users have to fill out is one more point of resistance between them and their conversion. Consider deleting optional fields and seeing if that lifts conversion. Giving visitors fewer distractions and fewer chances to leave the checkout funnel by removing choices can help boost conversion rates. Long forms have high risk for conversion failure. Breaking up a long form with required fields into multiple pages can increase chances for conversion. 3. Words Matter: Focus on Your Call to Action There are endless word combinations to use on your website. Don’t be afraid to brainstorm and think broadly: a testing platform lowers the “barrier to entry” of ideas, minimizes the risks of failure, and enables quick and potentially huge wins. Decisions around messaging and verbiage can easily lead to contentious debates on a team. A/B testing is a way to put opinions aside and get concrete feedback on what works and what doesn’t. If you want someone to do something, tell them to do it. Different ways of framing the same message can cause people to think of it in different ways. Play with alternative ways of framing the same information and see what differences emerge. 4. Fail Fast and Learn – Learning to Embrace the Times When A Beats B What works for returning users may not work for new users, and vice-versa. Something that works on one page may not work on another; something that works at one scale may not work at another. What one type of user wants may not be what another type of user wants. A failed test, sometimes more than a successful test, may prompt a drill-down that reveals a key difference between segments of users. Sometimes a variation may win against the original, but it may not win by enough of a margin to justify the implementation overhead or other drawbacks of the vari- ation that are external to the test itself. Any test that reveals that an initiative isn’t performing is a blessing in disguise: it allows you to free up resources from things that aren’t working and divert them to the things that are. 5. Choose the Solution That’s Right for Your OrganizationDeciding Whether to Build, Buy, or Hire Building your own testing platform requires a significant and ongoing engineering investment, but can ultimately provide the greatest level of control and the tightest integration with your team and deployment cycles. An A/A test is a helpful way to ensure that your solutionis functioning, reporting, and analyzing correctly. Many A/B testing Software-as-a-Service (SaaS) platforms are easy to use without requiring engineering support: marketers and product people without a coding background can create and run variations in a visual WYSIWYG environment. An agency can help your team with the ideation of tests, execution of tests, or both. When picking the solution that best fits your company, consider making key stakeholders part of the exploration process. The earlier you bring others on board, the easier it will be to get buy-in. 6. The Cure for the HiPPO Syndrome – Getting Buy-In and Proving Value In some workplaces, and to varying degrees, the HiPPO Syndrome holds sway, but often all it takes are a few humble tests and a curiosity and interest in testing begin to take root. Allay the wary with the reassurance that you’re not proposing sudden changes: it’s “just an experiment.” In month one, run a test that is politically palatable and easy enough that it can show a quick win. Product pages can be a great place to start. Share wins not only with your immediate boss but, if possible, with the company at large. Communication is key in getting people to care about testing. Get creative with how you introduce stakeholders and co-workers to A/B testing. 7. The A/B Testing Dream Team – Bringing Everyone Together A/B testing is by nature interdisciplinary and crossdepartmental. Collaboration is key. Some companies have a centralized testing team responsible for coordinating and executing all A/B tests companywide. Other organizations adopt a decentralized model, where each product owner/manager is responsible for testing within his or her product domain. Regardless of which structure you adopt, make sure there is at least one point person within the organization whom people can come to about all things testing. Ensure your point person or team maintains allies across your organization to ensure that testing is part of your planning process. Make sure that your testers are enabled and empowered to be creative, and that the friction of running and iterating new tests is low. Maintain records about who tested what and when, how the test was set up, and what the result was. This will enable your organization to work collaboratively to build up a set of collective wisdom and best practices. 8. Iterate – The Art of Asking Many Small Questions Rather than One Big One Multivariate tests are a powerful way to test a number of variables simultaneously, and can reveal interaction effects between them. However, they require more traffic and can be slower to achieve statistical significance. We have found that the companies that have had the greatest success with A/B testing favor a nimbler, more iterative approach that tests a handful of different variants of a single variable at a time and incorporates the winner as they go on to the next test. When working on a complex change like a site redesign, we recommend that you** move testing further up the process** so that it becomes something that happens during the design and rollout of the new site, rather than after. 9. How A/B Tests Can Go Awry – Potential Mistakes and Pitfalls to Avoid A/B testing can help even the smallest of organizations and sites, but it becomes more powerful the more traffic a site has. If your site is starved for traffic, A/B testing probably shouldn’t be your first priority. Testingwilloccasionallyrevealachangethatincreasesone metric but decreases another. Don’t push failure down the funnel. Considerwhetheryouarewillingtotestapagevariantthat is in some way off-brand or one that you wouldn’t necessarily be quick to roll out to all your users should it “win” the test. 10. How to Test Email and Pricing Not only the subject lines but the timing can be critical in influencing open rates and click-through rates for email. Roll out large email campaigns gradually, test variations, and then send the winner on to the rest of your list. Price testing can be one of the most important types of testing to conduct for your business, and there are a number of ways to do it. The last-minute discount is a great technique for testing price without needing to deal with back-end integration or worrying about upsetting users. Anchoring the price of a product into context with other prices can greatly affect how users react. Presentation can be everything when it comes to pricing. For a quick-and-easy price test, try various breakdowns (e.g., monthly, yearly, or weekly) and see what works best. Serial testing is one way to test prices without needing to show different users different prices at the same time; however, this advantage is offset by difficulties in ensuring the accuracy of its results. 11.Personalize – Moving Beyond the One-to-Many Web Segmentation allows you to compare how different segments of users responded to the same experience. Differences that you observe between groups can be illuminating and give you an opportunity to go beyond the average best experience of the one-to-many web toward an improved one-to-few experience. Targeting is deliberately providing different types of users with different experiences, and can be a powerful technique under many circumstances. Consider how your user experience may or may not be optimized across different platforms, screen dimensions, touch input versus mouse input, and so on. Sometimes geo-targeting, or tailoring users’ experience based on their location, can be an extremely powerful way to optimize beyond the “average best.” While personalization is frequently a boon for your success metrics, occasionally a universal call to action works better than a targeted one. Test to make sure personalization is working for your key success metrics. ConclusionA/B testing is at the vanguard of this massive shift. Now not only can you come up with creative, interesting ways to improve a user’s experience—you can measure that. Since for the first time it is now possible to clearly measure what works and what doesn’t work, businesses will evolve to focus on trying to ask the right questions and not prescribing the “right” answers. And the right questions can change everything. Reference:A/B TESTING The Most Powerful Way to Turn Clicks Into Customers","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"},{"name":"AB testing","slug":"Statistics/AB-testing","permalink":"http://haiming2048.github.io/categories/Statistics/AB-testing/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"AB testing","slug":"AB-testing","permalink":"http://haiming2048.github.io/tags/AB-testing/"}]},{"title":"A/B Testing Part I","slug":"AB-Testing","date":"2020-07-28T15:16:58.000Z","updated":"2020-07-28T20:27:38.274Z","comments":true,"path":"en/AB-Testing/","link":"","permalink":"http://haiming2048.github.io/en/AB-Testing/","excerpt":"","text":"This blog is about some key principles and insights that any tester or testing team should have in mind as they make their first forays into testing. The hardest part of A/B testing is determining what to test in the first place.One of the most common questions is, “Where do I begin?” A mistake that some companies make is to start moving a bunch of levers around without clear planning upfront for what they’re trying to optimize and what will be impacted by those changes. It’s tempting to just dive in and start changing parts of your homepage, or your product page, or your checkout page, without truly understanding the value that it’s generating (or not generating) for your business. Instead, In the book A/B TESTING The Most Powerful Way to Turn Clicks Into Customers, the authors advise a purposeful and deliberate five-step process: Step One: Define success Step Two: Identify bottlenecks Step Three: Construct a hypothesis Step Four: Prioritize Step Five: Test Step One: Define SuccessBefore you can determine which of your test’s variations is the winner, you have to first decide how you’re keeping score. To start A/B testing successfully, you need to answer a specific question: What is your website for? If you could make your website do one thing better, what would it do? Defining success in the context of A/B testing involves taking the answer to the question of your site’s ultimate purpose and turning it into something more precise: quantifiable success metrics. Your success metrics are the specific numbers you hope will be improved by your tests. It’s fairly easy for an e-commerce business to define its success metrics in terms of revenue per visitor and for a fundraising website to define its success metrics in terms of average donation per visitor. Depending on your business model, defining your success metrics may be trickier. Step Two: Identify BottlenecksOnce you’ve determined what your site’s quantifiable success metrics are, you can turn your attention to your site analytics and discover where your biggest bottlenecks are: the places where your users are dropping off, or the places where you’re losing the most momentum in moving users through your desired series of actions. Step Three: Construct a HypothesisOnce you’ve identified what the bottlenecks are in your process, use your understanding of visitor intent to come up with test hypotheses. Consider different forms of qualitative research such as user interviews, feedback forms, or focus groups to gain an understanding of what’s going on in users’ heads as they interact with your site. Hypotheses make tests more informative because they provide a specific purpose by helping you hone in on what you are actually trying to determine. If you run an experiment without forming a hypothesis beforehand, you might gather information that’s helpful anecdotally while missing the deeper lesson. Experimentation inherently generates more questions than it answers, and when used effectively will always validate or invalidate some hypothesis, thus lending focus to the next round of questions. “Failed” tests are valuable because they often lead to new hypotheses for why they didn’t turn out the way you expected. Generating these hypotheses is sometimes tricky, because visitors behave in complex ways. Regardless of the complexity, however, employing the scientific method in testing will bring you closer to a meaningful understanding of your website’s audience. Step Four: PrioritizeOnce you’ve generated hypotheses about user behavior that lead to candidate page variations for testing, you’ll need to use your intuition about what’s going to have the biggest impact to rankorder your experiments. In a perfect world, you might test absolutely everything, but no team in the real world operates without constraints; your team’s attention, budget, time, and also your site’s traffic are all finite. These realities make prioritization of testing hypotheses a necessity. Step Five: TestAll that’s left is to run the test. You’ll show randomly selected visitors the variation(s) and track how they behave relative to users seeing the current site with respect to the quantifiable success metrics you’ve determined. Once the test reaches statistical significance, you’ll have your answer. Often a completed test yields not only answers, but—as in any other science—more questions. And this cycle of iteration, of exploration and refinement. Summary: You can’t pick a winner until you decide how you’re keeping score. A/B testing starts with determining quantifiable success metrics. There are a number of possible conversion goals: time on site, pageviews, average order value, revenue per visitor, and so on. Take the time to pick the one that’s right for you. Site analytics along with your own instincts will suggest bottlenecks where you can focus your attention. Understanding visitor intent with the help of interviews and usability tests will suggest hypotheses about what to change and how. Prioritize your experiments based on your prediction of their impact. Start testing, and continue until you begin to see diminishing returns.","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"},{"name":"AB testing","slug":"Statistics/AB-testing","permalink":"http://haiming2048.github.io/categories/Statistics/AB-testing/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"AB testing","slug":"AB-testing","permalink":"http://haiming2048.github.io/tags/AB-testing/"}]},{"title":"Python Crash Course","slug":"Python_Crash_Course","date":"2020-07-27T18:51:42.000Z","updated":"2020-07-28T15:18:44.034Z","comments":true,"path":"en/Python_Crash_Course/","link":"","permalink":"http://haiming2048.github.io/en/Python_Crash_Course/","excerpt":"","text":"This blog is about python crash course, please check below links ( link to github) for more information.https://github.com/hming2048/Python-for-data-analysis-and-machine-learning/tree/master/python_crash_course","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Python","slug":"Data-Science/Python","permalink":"http://haiming2048.github.io/categories/Data-Science/Python/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Python","slug":"Python","permalink":"http://haiming2048.github.io/tags/Python/"}]},{"title":"SQL key points","slug":"sql","date":"2020-07-10T02:36:07.000Z","updated":"2020-07-28T20:14:20.751Z","comments":true,"path":"en/sql/","link":"","permalink":"http://haiming2048.github.io/en/sql/","excerpt":"","text":"what is SQL?SQL is short for the Structured Query Language, is a language designed to allow both techical and non-technical users query, manipulate, and transform data from a relational database. And due to its simplicity, SQL databases provide safe and scalable storage for millions of websites and mobile applications. There are many popular SQL databases including SQLite, MySQL, Postgres, Oracle and Microsoft SQL Server. All of them support the common SQL language standard, which is what this site will be teaching, but each implementation can differ in the additional features and storage types it supports. Relational databasesBefore we go detail of SQL, it’s important to have a model for what a relational database actually is. A relational database represents a collection of related (two-dimensional) tables. Each of the tables are similar to an Excel spreadsheet, with a fixed number of named columns (the attributes or properties of the table) and any number of rows of data. For example, if the Department of Motor Vehicles had a database, you might find a table containing all the known vehicles that people in the state are driving. This table might need to store the model name, type, number of wheels, and number of doors of each vehicle for example. Id Make/Model # Wheels # Doors Type 1 Ford Focus 4 4 2 Tesla Roadster 4 2 3 Kawakasi Ninja 2 0 4 McLaren Formula 1 4 0 5 Tesla S 4 4 In such a database, you might find additional related tables containing information such as a list of all registered drivers in the state, the types of driving licenses that can be granted, or even driving violations for each driver. SQL templateIn this blog, I will briefly conclude the template of executing SQL, and the order to write a SQL query. Below is a complete SELECT query template 123456789SELECT DISTINCT column, AGG_FUNC(column_or_expression), …FROM mytable JOIN another_table ON mytable.column = another_table.columnWHERE constraint_expressionGROUP BY columnHAVING constraint_expressionORDER BY column ASC/DESCLIMIT count OFFSET COUNT; Basically, Each query begins with finding the data that we need in a database, and then filtering that data down into something that can be processed and understood as quickly as possible. Because each part of the query is executed sequentially, it’s important to understand the order of execution so that you know what results are accessible where. Query order of execution1. FROM and JOINThe FROM clause, and subsequent JOIN are first executed to determine the total working set of data that is being queried. This includes subqueries in this clause, and can cause temporary tables to be created under the hood containing all the columns and rows of the tables being joined. 2. WHEREOnce we have the total working set of data, the first-pass WHERE constraints are applied to the individual rows, and rows that do not satisfy the constraint are discarded. Each of the constraints can only access columns directly from the tables requested in the FROM clause. Aliases in the SELECT part of the query are not accessible in most databases since they may include expressions dependent on parts of the query that have not yet executed. 3. GROUP BYThe remaining rows after the WHERE constraints are applied are then grouped based on common values in the column specified in the GROUP BY clause. As a result of the grouping, there will only be as many rows as there are unique values in that column. Implicitly, this means that you should only need to use this when you have aggregate functions in your query. 4. HAVINGIf the query has a GROUP BY clause, then the constraints in the HAVING clause are then applied to the grouped rows, discard the grouped rows that don’t satisfy the constraint. Like the WHERE clause, aliases are also not accessible from this step in most databases. 5. SELECTAny expressions in the SELECT part of the query are finally computed. 6. DISTINCTOf the remaining rows, rows with duplicate values in the column marked as DISTINCT will be discarded. 7. ORDER BYIf an order is specified by the ORDER BY clause, the rows are then sorted by the specified data in either ascending or descending order. Since all the expressions in the SELECT part of the query have been computed, you can reference aliases in this clause. 8. LIMIT / OFFSETFinally, the rows that fall outside the range specified by the LIMIT and OFFSET are discarded, leaving the final set of rows to be returned from the query. ConclusionNot every query needs to have all the parts we listed above, but a part of why SQL is so flexible is that it allows developers and data analysts to quickly manipulate data without having to write additional code, all just by using the above clauses. Recommand SQL exercise websites:Leetcode database: https://leetcode.com/problemset/database/SQLBolt: https://sqlbolt.com/HackRank: https://www.hackerrank.com/domains/sql Reference:https://sqlbolt.com/&gt;","categories":[{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/categories/Sql/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/tags/Sql/"}]},{"title":"Interesting probability problems with coins","slug":"probability","date":"2020-07-03T01:48:21.000Z","updated":"2020-07-28T20:14:04.769Z","comments":true,"path":"en/probability/","link":"","permalink":"http://haiming2048.github.io/en/probability/","excerpt":"","text":"Problems1. What is the expected number of coin flips for getting a head?Solution:Let the expected number of coin flips be x. Then we can write an equation for it a. If the first flip is the head, then we are done. The probability of this event is 1/2 and the number of coin flips for this event is 1. b. If the first flip is the tails, then we have wasted one flip. Since consecutive flips are independent events, the solution in this case can be recursively framed in terms of x - The probability of this event is 1/2 and the expected number of coins flips now onwards is x. But we have already wasted one flip, so the total number of flips is x+1. The expected value x is the sum of the expected values of these two cases. Using the rule of linerairty of the expectation and the definition of Expected value(E[x] = x1p1 + x2p2 + … + xnpn), we get x = (1/2)(1) + (1/2) (1+x)Solving, we get x = 2. Thus the expected number of coin flips for getting a head is 2. 2. What is the expected number of coin flips for getting two consecutive heads?Solution:This question is a litter complecated than question #1 but we can still use the pattern of question #1 to solve this problem. Let the expected number of coin flips be x. The case analysis goes as follows: a. If the first flip is a tails, then we have wasted one flip. The probability of this event is 1/2 and the total number of flips required is x+1 b. If the first flip is a heads and second flip is a tails, then we have wasted two flips. The probability of this event is 1/4 and the total number of flips required is x+2 c. If the first flip is a heads and second flip is also heads, then we are done. The probability of this event is 1/4 and the total number of flips required is 2. Adding, the equation that we get is - x = (1/2)(x+1) + (1/4)(x+2) + (1/4)2Solving, we get x = 6. Thus, the expected number of coin flips for getting two consecutive heads is 6. 3. (Generalization) What is the expected number of coin flips for getting N consecutive heads, given N?Solution:Let the exepected number of coin flips be x. Based on previous exercises, we can wind up the whole case analysis in two basic parts a. If we get 1st, 2nd, 3rd,…,n’th tail as the first tail in the experiment, then we have to start all over again. b. Else we are done. For the 1st flip as tail, the part of the equation is (1/2)(x+1)For the 2nd flip as tail, the part of the equation is (1/4)(x+2)…For the k’th flip as tail, the part of the equation is (1/(2k))(x+k)…For the N’th flip as tail, the part of the equation is (1/(2N))(x+N)The part of equation corrresponding to case (b) is (1/(2N))(N) Adding, x = (1/2)(x+1) + (1/4)(x+2) + … + (1/(2k))(x+k) + … + (1/(2N))(x+N) + (1/(2N))(N) Solving this equation that we get is - x = (2N+1) - 2 Thus, the expected number of coin flips for getting N consecutive heads is (2N+1) - 2 . 4. Given a biased coin that comes up heads with some probability greater than one-half and less than one(0.5 &lt; p &lt; 1 ), can we use it to simulate an unbiased coin tossSolution:A simple solution, attributed to von Neumann, makes use of symmetry. Let us flip the coin twice. If it comes up heads first and tails second, then we call it a 0. If it comes up tails first and heads second, then we call it a 1. If the two flips are the same, we flip twice again, and repeat the process until we have a unbiased toss. If we define a round to be a pair of flips, it is clear that we the probability of generating a 0 or a 1 is the same each round, so we correctly simulate an unbiased coin. For convenience, we will call the 0 or 1 produced by our simulated unbiased coin a bit, which is the appropriate term for a computer scientist.Interestingly enough, this solution works regardless of the probability that the coin lands heads up, even if this probability is unknown! This property seems highly advantageous, as we may not know the bias of a coin ahead of time. Reference:https://www.codechef.com/wiki/tutorial-expectationhttp://www.eecs.harvard.edu/~michaelm/coinflipext.pdf","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"},{"name":"Statistics","slug":"Statistics/Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/Statistics/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"Probability","slug":"Probability","permalink":"http://haiming2048.github.io/tags/Probability/"}]},{"title":"What is P-Value?","slug":"p-value","date":"2020-06-27T03:00:13.000Z","updated":"2020-07-28T20:13:54.590Z","comments":true,"path":"en/p-value/","link":"","permalink":"http://haiming2048.github.io/en/p-value/","excerpt":"","text":"What Is P-Value?In statistics, the p-value is the probability of obtaining results as extreme as the observed results of a statistical hypothesis test, assuming that the null hypothesis is correct. The p-value is used as an alternative to rejection points to provide the smallest level of significance at which the null hypothesis would be rejected. A smaller p-value means that there is stronger evidence in favor of the alternative hypothesis. Basically, when you perform a hypothesis test in statistics, a p-value helps you determine the significance of our results. Hypothesis tests are used to test the validity of a claim that is made about a population. This claim that’s on trial, in essence, is called the null hypothesis. The alternative hypothesis is the one you would believe if the null hypothesis is concluded to be untrue. The evidence in the trial is your data and the statistics that go along with it. All hypothesis tests ultimately use a p-value to weigh the strength of the evidence (what the data are telling you about the population). The p-value is a number between 0 and 1 and interpreted in the following way: A small p-value (typically ≤ 0.05) indicates strong evidence against the null hypothesis, so you reject the null hypothesis. A large p-value (&gt; 0.05) indicates weak evidence against the null hypothesis, so you fail to reject the null hypothesis. p-values very close to the cutoff (0.05) are considered to be marginal (could go either way). Always report the p-value so your readers can draw their own conclusions. The following figure shows the locations of a test statistic and their corresponding conclusions. Example Suppose a pizza place claims their delivery times are 30 minutes or less on average but you think it’s more than that. You conduct a hypothesis test because you believe the null hypothesis, H0, that the mean delivery time is 30 minutes max, is incorrect. Your alternative hypothesis (H1) is that the mean time is greater than 30 minutes. You randomly sample some delivery times and run the data through the hypothesis test, and your p-value turns out to be 0.001, which is much less than 0.05. In real terms, there is a probability of 0.05 that you will mistakenly reject the pizza place’s claim that their delivery time is less than or equal to 30 minutes. Since typically we are willing to reject the null hypothesis when this probability is less than 0.05, you conclude that the pizza place is wrong. Their delivery times are in fact more than 30 minutes on average, and you want to know what they’re gonna do about it! (Of course, you could be wrong by having sampled an unusually high number of late pizza deliveries just by chance.) Reference:https://www.dummies.com/education/math/statistics/how-to-determine-a-p-value-when-testing-a-null-hypothesis/","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"},{"name":"Statistics","slug":"Statistics/Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/Statistics/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"P-value","slug":"P-value","permalink":"http://haiming2048.github.io/tags/P-value/"}]},{"title":"Binary Search Summary","slug":"Binary_search_summary","date":"2020-06-25T15:34:55.000Z","updated":"2020-07-28T15:24:40.991Z","comments":true,"path":"en/Binary_search_summary/","link":"","permalink":"http://haiming2048.github.io/en/Binary_search_summary/","excerpt":"","text":"How Binary Search workBinary Search operates on a contiguous sequence with a specified left and right index. This is called the Search Space.Binary Search maintains the left, right, and middle indicies of the search space and compares the search target or applies the search condition to the middle value of the collection; if the condition is unsatisfied or values unequal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful. If the search ends with an empty half, the condition cannot be fulfilled and target is not found. NoteBinary Search can take many alternate forms and might not always be as straight forward as searching for a specific value. Sometimes you will have to apply a specific condition or rule to determine which side (left or right) to search next. TemplatesBasically, there are three templates we will often use in Binary Search, I will introduce them latter. How do we identify Binary Search?As mentioned in earlier, Binary Search is an algorithm that divides the search space in 2 after every comparison. Binary Search should be considered every time you need to search for an index or element in a collection. If the collection is unordered, we can always sort it first before applying Binary Search. 3 Parts of a Successful Binary SearchBinary Search is generally composed of 3 main sections:1. Pre-processing - Sort if collection is unsorted.2. Binary Search - Using a loop or recursion to divide search space in half after each comparison.3. Post-processing - Determine viable candidates in the remaining space. Binary Search Template I123456789101112131415161718192021def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 # End Condition: left &gt; right return -1 Template #1 is the most basic and elementary form of Binary Search. It is the standard Binary Search Template that most high schools or universities use when they first teach students computer science.Template #1 is used to search for an element or condition which can be determined by accessing a single index in the array. Key Attributes: An advanced way to implement Binary Search. Search Condition needs to access element’s immediate right neighbor Use element’s right neighbor to determine if condition is met and decide whether to go left or right Gurantees Search Space is at least 2 in size at each step Post-processing required. Loop/Recursion ends when you have 1 element left. Need to assess if the remaining element meets the condition. Distinguishing Syntax: Initial Condition: left = 0, right = length Termination: left == right Searching Left: right = mid Searching Right: left = mid+1 Template #1 Example Leetcode: #69. Sqrt(x)123456789101112131415161718192021222324252627282930313233'''Leetcode: #69. Sqrt(x)Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.'''# Binary Search solotionclass Solution: def mySqrt(self, x: int) -&gt; int: left = 0 right = x while left &lt;= right: mid = left + (right - left) // 2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right Other simily questions using this template: Leetcode(#33, #374) Binary Search Template II123456789101112131415161718192021222324def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) while left &lt; right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid # Post-processing: # End Condition: left == right if left != len(nums) and nums[left] == target: return left return -1 Template #2 is an advanced form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate right neighbor’s index in the array. Key Attributes: Most basic and elementary form of Binary Search Search Condition can be determined without comparing to the element’s neighbors (or use specific elements around it) No post-processing required because at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found Distinguishing Syntax: Initial Condition: left = 0, right = length-1 Termination: left &gt; right Searching Left: right = mid-1 Searching Right: left = mid+1 Template #2 Example Leetcode: #278. First Bad Version123456789101112131415161718192021222324252627282930313233343536'''Leetcode: #278. First Bad VersionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.Example:Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. '''# Binary Search solotionclass Solution: def firstBadVersion(self, n): left = 1 right = n while left &lt; right: mid = (left + right ) //2 if isBadVersion(mid): right = mid else: left = mid + 1 return left Other simily questions using this template: Leetcode(#153, #162) Binary Search Template III123456789101112131415161718192021222324def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) while left &lt; right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid # Post-processing: # End Condition: left == right if left != len(nums) and nums[left] == target: return left return -1 Template #3 is another unique form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate left and right neighbor’s index in the array. Key Attributes: An alternative way to implement Binary Search Search Condition needs to access element’s immediate left and right neighbors Use element’s neighbors to determine if condition is met and decide whether to go left or right Gurantees Search Space is at least 3 in size at each step Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition. Distinguishing Syntax: Initial Condition: left = 0, right = length-1 Termination: left + 1 == right Searching Left: right = mid Searching Right: left = mid Template #3 Example Leetcode: #34. Find First and Last Position of Element in Sorted Array 1234567891011121314151617181920212223242526272829303132333435'''Leetcode: #34. Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm's runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].Example 1:Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Example 2:Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]'''# Binary Search solotionclass Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: if not nums: return [-1,-1] def lower(data, target): l,r = 0,len(data) while l &lt; r: mid = (l+r)//2 if target &gt; data[mid]: l = mid + 1 else: r = mid return l left = lower(nums, target) right = lower(nums, target+1)-1 return [left, right] if left &lt; len(nums) and nums[left]==target else [-1,-1] Other simily questions using this template: Leetcode(#162, #658) Reference:Leetcode: https://leetcode.com/explore/learn/card/binary-search","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://haiming2048.github.io/categories/Algorithm/"},{"name":"Binary Searach","slug":"Algorithm/Binary-Searach","permalink":"http://haiming2048.github.io/categories/Algorithm/Binary-Searach/"}],"tags":[{"name":"Binary Searach","slug":"Binary-Searach","permalink":"http://haiming2048.github.io/tags/Binary-Searach/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://haiming2048.github.io/tags/Leetcode/"}]},{"title":"Statistics Notation","slug":"statistics_Notation","date":"2020-06-01T00:34:25.000Z","updated":"2020-07-28T20:14:14.877Z","comments":true,"path":"en/statistics_Notation/","link":"","permalink":"http://haiming2048.github.io/en/statistics_Notation/","excerpt":"","text":"What is Statistics it is the science of collecting, summarizing, presenting and analyzing data from the purpose of drawing conclusions and making decisions the common used notations in statistics:Population &amp; Sample Population is a collection of all units of interest(may be people, households, geographic regions items produced ets). A sample is a subset of population from which the data is collected Parameter A numerical characteristic of a population defined for a specific variable (Examples: Population mean, population proportion etc.) Variables We are interested in one or more measurable properties or attributes associated with each unit in the population. These properties are called variables. Population Parameters(or simply Parameters) summarize data for an entire population; Example: Population mean, Population proportion, population standard deviation Sample Statistics (or simply Statistics) summarize data from a sample; Example: Sample mean, Sample proportion, Sample standard deviation Estimate A sample statistic used to estimate an unknown population parameter Sampling distribution which is the probability distribution of a sample statistic. Random Experiment Procedure or an operation whose outcome is uncertain and cannot be predicted in advance. Sample Space The collection of all possible outcomes of a random experiment events – Set of outcomes of a random experiment probability distribution A probability distribution is a formula or a table used to assign probabilities to each possible value of a random variable X. A probability distribution may be either discrete or continuous. A discrete distribution means that X can assume one of a countable (usually finite) number of values, while a continuous distribution means that X can assume one of an infinite (uncountable) number of different values.","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"},{"name":"Statistics","slug":"Statistics/Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/Statistics/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"}]},{"title":"The common used commands in Hexo","slug":"hexo-commands","date":"2020-05-30T06:31:32.000Z","updated":"2020-07-27T18:50:34.985Z","comments":true,"path":"en/hexo-commands/","link":"","permalink":"http://haiming2048.github.io/en/hexo-commands/","excerpt":"","text":"The common used hexo’s command1. Create a new article $ hexo new [layout] &lt;title&gt; If no layout provided, Hexo will use the default_layout from _config.yml Such as hexo new test, will create a new article nameed as test 2. Generate $ hexo generate or hexo g Genarate static files, then you can find the output files in public folder 3. Server $ hexo server or hexo s Starts a local server. By default, this is at http://localhost:4000/ 4. Deploy $ hexo deploy or hexo d Deploys your web site, you can deploy your web on github pages, check this links for more information. https://hexo.io/docs/github-pages 5. clean $ hexo clean Cleans the cache file(db.json) and generated files(piblic). Those above commands are common used in hexo when we try to write a new article or try to deploy our web page on github. Besides, there are some other commands you may need to use sometimes, but not very often.Such as: $ hexo publish [layout] &lt;filename&gt; Publishes a draft $ hexo migrate &lt;type&gt; Migrates content from other blog systems. $ hexo list &lt;type&gt; Lists all routes $ hexo version Displays version information $ hexo --cwd /path/to/cwd Customizes the path of current working directory. $ hexo --draft Displays draft posts (stored in the source/_drafts folder).","categories":[],"tags":[]},{"title":"Data Science","slug":"data_science","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-06T03:22:25.942Z","comments":true,"path":"en/data_science/","link":"","permalink":"http://haiming2048.github.io/en/data_science/","excerpt":"","text":"This article is about Data science notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"}]},{"title":"Machine Learning","slug":"python_ML","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T00:46:18.693Z","comments":true,"path":"en/python_ML/","link":"","permalink":"http://haiming2048.github.io/en/python_ML/","excerpt":"","text":"This article is about Machine Learning notes, coming soon!","categories":[{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/categories/ML/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/tags/ML/"}]},{"title":"Python Pandas","slug":"python_pandas","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T02:35:42.863Z","comments":true,"path":"en/python_pandas/","link":"","permalink":"http://haiming2048.github.io/en/python_pandas/","excerpt":"","text":"This article is about python pandas library notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Pandas","slug":"Data-Science/Pandas","permalink":"http://haiming2048.github.io/categories/Data-Science/Pandas/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Pandas","slug":"Pandas","permalink":"http://haiming2048.github.io/tags/Pandas/"}]},{"title":"Python Plots","slug":"python_plot","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T02:46:13.026Z","comments":true,"path":"en/python_plot/","link":"","permalink":"http://haiming2048.github.io/en/python_plot/","excerpt":"","text":"This article is about python Plots(include: matplot, seaborn, plotly) library notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Plot","slug":"Data-Science/Plot","permalink":"http://haiming2048.github.io/categories/Data-Science/Plot/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Plot","slug":"Plot","permalink":"http://haiming2048.github.io/tags/Plot/"}]}],"categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"},{"name":"AB testing","slug":"Statistics/AB-testing","permalink":"http://haiming2048.github.io/categories/Statistics/AB-testing/"},{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Python","slug":"Data-Science/Python","permalink":"http://haiming2048.github.io/categories/Data-Science/Python/"},{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/categories/Sql/"},{"name":"Statistics","slug":"Statistics/Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/Statistics/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://haiming2048.github.io/categories/Algorithm/"},{"name":"Binary Searach","slug":"Algorithm/Binary-Searach","permalink":"http://haiming2048.github.io/categories/Algorithm/Binary-Searach/"},{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/categories/ML/"},{"name":"Pandas","slug":"Data-Science/Pandas","permalink":"http://haiming2048.github.io/categories/Data-Science/Pandas/"},{"name":"Plot","slug":"Data-Science/Plot","permalink":"http://haiming2048.github.io/categories/Data-Science/Plot/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"AB testing","slug":"AB-testing","permalink":"http://haiming2048.github.io/tags/AB-testing/"},{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Python","slug":"Python","permalink":"http://haiming2048.github.io/tags/Python/"},{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/tags/Sql/"},{"name":"Probability","slug":"Probability","permalink":"http://haiming2048.github.io/tags/Probability/"},{"name":"P-value","slug":"P-value","permalink":"http://haiming2048.github.io/tags/P-value/"},{"name":"Binary Searach","slug":"Binary-Searach","permalink":"http://haiming2048.github.io/tags/Binary-Searach/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://haiming2048.github.io/tags/Leetcode/"},{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/tags/ML/"},{"name":"Pandas","slug":"Pandas","permalink":"http://haiming2048.github.io/tags/Pandas/"},{"name":"Plot","slug":"Plot","permalink":"http://haiming2048.github.io/tags/Plot/"}]}