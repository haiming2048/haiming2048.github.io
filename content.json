{"meta":{"title":"Haiming","subtitle":"Hacker inside","description":"description....","author":"Haiming","url":"http://haiming2048.github.io","root":"/"},"pages":[],"posts":[{"title":"Python Crash Course","slug":"Python_Crash_Course","date":"2020-07-27T18:51:42.000Z","updated":"2020-07-27T19:10:59.228Z","comments":true,"path":"en/Python_Crash_Course/","link":"","permalink":"http://haiming2048.github.io/en/Python_Crash_Course/","excerpt":"","text":"This blog is about python crash course, please check below links ( link to github) for more information.https://github.com/hming2048/Python-for-data-analysis-and-machine-learning/tree/master/python_crash_course","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Python","slug":"Python","permalink":"http://haiming2048.github.io/tags/Python/"}]},{"title":"SQL key points","slug":"sql","date":"2020-07-10T02:36:07.000Z","updated":"2020-07-10T03:23:00.847Z","comments":true,"path":"en/sql/","link":"","permalink":"http://haiming2048.github.io/en/sql/","excerpt":"","text":"what is SQL?SQL is short for the Structured Query Language, is a language designed to allow both techical and non-technical users query, manipulate, and transform data from a relational database. And due to its simplicity, SQL databases provide safe and scalable storage for millions of websites and mobile applications. There are many popular SQL databases including SQLite, MySQL, Postgres, Oracle and Microsoft SQL Server. All of them support the common SQL language standard, which is what this site will be teaching, but each implementation can differ in the additional features and storage types it supports. Relational databasesBefore we go detail of SQL, it’s important to have a model for what a relational database actually is. A relational database represents a collection of related (two-dimensional) tables. Each of the tables are similar to an Excel spreadsheet, with a fixed number of named columns (the attributes or properties of the table) and any number of rows of data. For example, if the Department of Motor Vehicles had a database, you might find a table containing all the known vehicles that people in the state are driving. This table might need to store the model name, type, number of wheels, and number of doors of each vehicle for example. Id Make/Model # Wheels # Doors Type 1 Ford Focus 4 4 2 Tesla Roadster 4 2 3 Kawakasi Ninja 2 0 4 McLaren Formula 1 4 0 5 Tesla S 4 4 In such a database, you might find additional related tables containing information such as a list of all registered drivers in the state, the types of driving licenses that can be granted, or even driving violations for each driver. SQL templateIn this blog, I will briefly conclude the template of executing SQL, and the order to write a SQL query. Below is a complete SELECT query template 123456789SELECT DISTINCT column, AGG_FUNC(column_or_expression), …FROM mytable JOIN another_table ON mytable.column = another_table.columnWHERE constraint_expressionGROUP BY columnHAVING constraint_expressionORDER BY column ASC/DESCLIMIT count OFFSET COUNT; Basically, Each query begins with finding the data that we need in a database, and then filtering that data down into something that can be processed and understood as quickly as possible. Because each part of the query is executed sequentially, it’s important to understand the order of execution so that you know what results are accessible where. Query order of execution1. FROM and JOINThe FROM clause, and subsequent JOIN are first executed to determine the total working set of data that is being queried. This includes subqueries in this clause, and can cause temporary tables to be created under the hood containing all the columns and rows of the tables being joined. 2. WHEREOnce we have the total working set of data, the first-pass WHERE constraints are applied to the individual rows, and rows that do not satisfy the constraint are discarded. Each of the constraints can only access columns directly from the tables requested in the FROM clause. Aliases in the SELECT part of the query are not accessible in most databases since they may include expressions dependent on parts of the query that have not yet executed. 3. GROUP BYThe remaining rows after the WHERE constraints are applied are then grouped based on common values in the column specified in the GROUP BY clause. As a result of the grouping, there will only be as many rows as there are unique values in that column. Implicitly, this means that you should only need to use this when you have aggregate functions in your query. 4. HAVINGIf the query has a GROUP BY clause, then the constraints in the HAVING clause are then applied to the grouped rows, discard the grouped rows that don’t satisfy the constraint. Like the WHERE clause, aliases are also not accessible from this step in most databases. 5. SELECTAny expressions in the SELECT part of the query are finally computed. 6. DISTINCTOf the remaining rows, rows with duplicate values in the column marked as DISTINCT will be discarded. 7. ORDER BYIf an order is specified by the ORDER BY clause, the rows are then sorted by the specified data in either ascending or descending order. Since all the expressions in the SELECT part of the query have been computed, you can reference aliases in this clause. 8. LIMIT / OFFSETFinally, the rows that fall outside the range specified by the LIMIT and OFFSET are discarded, leaving the final set of rows to be returned from the query. ConclusionNot every query needs to have all the parts we listed above, but a part of why SQL is so flexible is that it allows developers and data analysts to quickly manipulate data without having to write additional code, all just by using the above clauses. Recommand SQL exercise websites:Leetcode database: https://leetcode.com/problemset/database/SQLBolt: https://sqlbolt.com/HackRank: https://www.hackerrank.com/domains/sql Reference:https://sqlbolt.com/&gt;","categories":[{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/categories/Sql/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/tags/Sql/"}]},{"title":"Interesting probability problems with coins","slug":"probability","date":"2020-07-03T01:48:21.000Z","updated":"2020-07-12T13:33:42.731Z","comments":true,"path":"en/probability/","link":"","permalink":"http://haiming2048.github.io/en/probability/","excerpt":"","text":"Problems1. What is the expected number of coin flips for getting a head?Solution:Let the expected number of coin flips be x. Then we can write an equation for it a. If the first flip is the head, then we are done. The probability of this event is 1/2 and the number of coin flips for this event is 1. b. If the first flip is the tails, then we have wasted one flip. Since consecutive flips are independent events, the solution in this case can be recursively framed in terms of x - The probability of this event is 1/2 and the expected number of coins flips now onwards is x. But we have already wasted one flip, so the total number of flips is x+1. The expected value x is the sum of the expected values of these two cases. Using the rule of linerairty of the expectation and the definition of Expected value(E[x] = x1p1 + x2p2 + … + xnpn), we get x = (1/2)(1) + (1/2) (1+x)Solving, we get x = 2. Thus the expected number of coin flips for getting a head is 2. 2. What is the expected number of coin flips for getting two consecutive heads?Solution:This question is a litter complecated than question #1 but we can still use the pattern of question #1 to solve this problem. Let the expected number of coin flips be x. The case analysis goes as follows: a. If the first flip is a tails, then we have wasted one flip. The probability of this event is 1/2 and the total number of flips required is x+1 b. If the first flip is a heads and second flip is a tails, then we have wasted two flips. The probability of this event is 1/4 and the total number of flips required is x+2 c. If the first flip is a heads and second flip is also heads, then we are done. The probability of this event is 1/4 and the total number of flips required is 2. Adding, the equation that we get is - x = (1/2)(x+1) + (1/4)(x+2) + (1/4)2Solving, we get x = 6. Thus, the expected number of coin flips for getting two consecutive heads is 6. 3. (Generalization) What is the expected number of coin flips for getting N consecutive heads, given N?Solution:Let the exepected number of coin flips be x. Based on previous exercises, we can wind up the whole case analysis in two basic parts a. If we get 1st, 2nd, 3rd,…,n’th tail as the first tail in the experiment, then we have to start all over again. b. Else we are done. For the 1st flip as tail, the part of the equation is (1/2)(x+1)For the 2nd flip as tail, the part of the equation is (1/4)(x+2)…For the k’th flip as tail, the part of the equation is (1/(2k))(x+k)…For the N’th flip as tail, the part of the equation is (1/(2N))(x+N)The part of equation corrresponding to case (b) is (1/(2N))(N) Adding, x = (1/2)(x+1) + (1/4)(x+2) + … + (1/(2k))(x+k) + … + (1/(2N))(x+N) + (1/(2N))(N) Solving this equation that we get is - x = (2N+1) - 2 Thus, the expected number of coin flips for getting N consecutive heads is (2N+1) - 2 . 4. Given a biased coin that comes up heads with some probability greater than one-half and less than one(0.5 &lt; p &lt; 1 ), can we use it to simulate an unbiased coin tossSolution:A simple solution, attributed to von Neumann, makes use of symmetry. Let us flip the coin twice. If it comes up heads first and tails second, then we call it a 0. If it comes up tails first and heads second, then we call it a 1. If the two flips are the same, we flip twice again, and repeat the process until we have a unbiased toss. If we define a round to be a pair of flips, it is clear that we the probability of generating a 0 or a 1 is the same each round, so we correctly simulate an unbiased coin. For convenience, we will call the 0 or 1 produced by our simulated unbiased coin a bit, which is the appropriate term for a computer scientist.Interestingly enough, this solution works regardless of the probability that the coin lands heads up, even if this probability is unknown! This property seems highly advantageous, as we may not know the bias of a coin ahead of time. Reference:https://www.codechef.com/wiki/tutorial-expectationhttp://www.eecs.harvard.edu/~michaelm/coinflipext.pdf","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"Probability","slug":"Probability","permalink":"http://haiming2048.github.io/tags/Probability/"}]},{"title":"What is P-Value?","slug":"p-value","date":"2020-06-27T03:00:13.000Z","updated":"2020-07-12T03:22:43.698Z","comments":true,"path":"en/p-value/","link":"","permalink":"http://haiming2048.github.io/en/p-value/","excerpt":"","text":"What Is P-Value?In statistics, the p-value is the probability of obtaining results as extreme as the observed results of a statistical hypothesis test, assuming that the null hypothesis is correct. The p-value is used as an alternative to rejection points to provide the smallest level of significance at which the null hypothesis would be rejected. A smaller p-value means that there is stronger evidence in favor of the alternative hypothesis. Basically, when you perform a hypothesis test in statistics, a p-value helps you determine the significance of our results. Hypothesis tests are used to test the validity of a claim that is made about a population. This claim that’s on trial, in essence, is called the null hypothesis. The alternative hypothesis is the one you would believe if the null hypothesis is concluded to be untrue. The evidence in the trial is your data and the statistics that go along with it. All hypothesis tests ultimately use a p-value to weigh the strength of the evidence (what the data are telling you about the population). The p-value is a number between 0 and 1 and interpreted in the following way: A small p-value (typically ≤ 0.05) indicates strong evidence against the null hypothesis, so you reject the null hypothesis. A large p-value (&gt; 0.05) indicates weak evidence against the null hypothesis, so you fail to reject the null hypothesis. p-values very close to the cutoff (0.05) are considered to be marginal (could go either way). Always report the p-value so your readers can draw their own conclusions. The following figure shows the locations of a test statistic and their corresponding conclusions. Example Suppose a pizza place claims their delivery times are 30 minutes or less on average but you think it’s more than that. You conduct a hypothesis test because you believe the null hypothesis, H0, that the mean delivery time is 30 minutes max, is incorrect. Your alternative hypothesis (H1) is that the mean time is greater than 30 minutes. You randomly sample some delivery times and run the data through the hypothesis test, and your p-value turns out to be 0.001, which is much less than 0.05. In real terms, there is a probability of 0.05 that you will mistakenly reject the pizza place’s claim that their delivery time is less than or equal to 30 minutes. Since typically we are willing to reject the null hypothesis when this probability is less than 0.05, you conclude that the pizza place is wrong. Their delivery times are in fact more than 30 minutes on average, and you want to know what they’re gonna do about it! (Of course, you could be wrong by having sampled an unusually high number of late pizza deliveries just by chance.) Reference:https://www.dummies.com/education/math/statistics/how-to-determine-a-p-value-when-testing-a-null-hypothesis/","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"P-value","slug":"P-value","permalink":"http://haiming2048.github.io/tags/P-value/"}]},{"title":"Binary Search Summary","slug":"Binary_search_summary","date":"2020-06-25T15:34:55.000Z","updated":"2020-06-27T03:34:41.771Z","comments":true,"path":"en/Binary_search_summary/","link":"","permalink":"http://haiming2048.github.io/en/Binary_search_summary/","excerpt":"","text":"How Binary Search workBinary Search operates on a contiguous sequence with a specified left and right index. This is called the Search Space.Binary Search maintains the left, right, and middle indicies of the search space and compares the search target or applies the search condition to the middle value of the collection; if the condition is unsatisfied or values unequal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful. If the search ends with an empty half, the condition cannot be fulfilled and target is not found. NoteBinary Search can take many alternate forms and might not always be as straight forward as searching for a specific value. Sometimes you will have to apply a specific condition or rule to determine which side (left or right) to search next. TemplatesBasically, there are three templates we will often use in Binary Search, I will introduce them latter. How do we identify Binary Search?As mentioned in earlier, Binary Search is an algorithm that divides the search space in 2 after every comparison. Binary Search should be considered every time you need to search for an index or element in a collection. If the collection is unordered, we can always sort it first before applying Binary Search. 3 Parts of a Successful Binary SearchBinary Search is generally composed of 3 main sections:1. Pre-processing - Sort if collection is unsorted.2. Binary Search - Using a loop or recursion to divide search space in half after each comparison.3. Post-processing - Determine viable candidates in the remaining space. Binary Search Template I123456789101112131415161718192021def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 # End Condition: left &gt; right return -1 Template #1 is the most basic and elementary form of Binary Search. It is the standard Binary Search Template that most high schools or universities use when they first teach students computer science.Template #1 is used to search for an element or condition which can be determined by accessing a single index in the array. Key Attributes: An advanced way to implement Binary Search. Search Condition needs to access element’s immediate right neighbor Use element’s right neighbor to determine if condition is met and decide whether to go left or right Gurantees Search Space is at least 2 in size at each step Post-processing required. Loop/Recursion ends when you have 1 element left. Need to assess if the remaining element meets the condition. Distinguishing Syntax: Initial Condition: left = 0, right = length Termination: left == right Searching Left: right = mid Searching Right: left = mid+1 Template #1 Example Leetcode: #69. Sqrt(x)123456789101112131415161718192021222324252627282930313233'''Leetcode: #69. Sqrt(x)Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.'''# Binary Search solotionclass Solution: def mySqrt(self, x: int) -&gt; int: left = 0 right = x while left &lt;= right: mid = left + (right - left) // 2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right Other simily questions using this template: Leetcode(#33, #374) Binary Search Template II123456789101112131415161718192021222324def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) while left &lt; right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid # Post-processing: # End Condition: left == right if left != len(nums) and nums[left] == target: return left return -1 Template #2 is an advanced form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate right neighbor’s index in the array. Key Attributes: Most basic and elementary form of Binary Search Search Condition can be determined without comparing to the element’s neighbors (or use specific elements around it) No post-processing required because at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found Distinguishing Syntax: Initial Condition: left = 0, right = length-1 Termination: left &gt; right Searching Left: right = mid-1 Searching Right: left = mid+1 Template #2 Example Leetcode: #278. First Bad Version123456789101112131415161718192021222324252627282930313233343536'''Leetcode: #278. First Bad VersionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.Example:Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. '''# Binary Search solotionclass Solution: def firstBadVersion(self, n): left = 1 right = n while left &lt; right: mid = (left + right ) //2 if isBadVersion(mid): right = mid else: left = mid + 1 return left Other simily questions using this template: Leetcode(#153, #162) Binary Search Template III123456789101112131415161718192021222324def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) while left &lt; right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid # Post-processing: # End Condition: left == right if left != len(nums) and nums[left] == target: return left return -1 Template #3 is another unique form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate left and right neighbor’s index in the array. Key Attributes: An alternative way to implement Binary Search Search Condition needs to access element’s immediate left and right neighbors Use element’s neighbors to determine if condition is met and decide whether to go left or right Gurantees Search Space is at least 3 in size at each step Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition. Distinguishing Syntax: Initial Condition: left = 0, right = length-1 Termination: left + 1 == right Searching Left: right = mid Searching Right: left = mid Template #3 Example Leetcode: #34. Find First and Last Position of Element in Sorted Array 1234567891011121314151617181920212223242526272829303132333435'''Leetcode: #34. Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm's runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].Example 1:Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Example 2:Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]'''# Binary Search solotionclass Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: if not nums: return [-1,-1] def lower(data, target): l,r = 0,len(data) while l &lt; r: mid = (l+r)//2 if target &gt; data[mid]: l = mid + 1 else: r = mid return l left = lower(nums, target) right = lower(nums, target+1)-1 return [left, right] if left &lt; len(nums) and nums[left]==target else [-1,-1] Other simily questions using this template: Leetcode(#162, #658) Reference:Leetcode: https://leetcode.com/explore/learn/card/binary-search","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://haiming2048.github.io/categories/Algorithm/"}],"tags":[{"name":"Binary Searach","slug":"Binary-Searach","permalink":"http://haiming2048.github.io/tags/Binary-Searach/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://haiming2048.github.io/tags/Leetcode/"}]},{"title":"Statistics Notation","slug":"statistics_Notation","date":"2020-06-01T00:34:25.000Z","updated":"2020-06-27T03:35:02.465Z","comments":true,"path":"en/statistics_Notation/","link":"","permalink":"http://haiming2048.github.io/en/statistics_Notation/","excerpt":"","text":"What is Statistics it is the science of collecting, summarizing, presenting and analyzing data from the purpose of drawing conclusions and making decisions the common used notations in statistics:Population &amp; Sample Population is a collection of all units of interest(may be people, households, geographic regions items produced ets). A sample is a subset of population from which the data is collected Parameter A numerical characteristic of a population defined for a specific variable (Examples: Population mean, population proportion etc.) Variables We are interested in one or more measurable properties or attributes associated with each unit in the population. These properties are called variables. Population Parameters(or simply Parameters) summarize data for an entire population; Example: Population mean, Population proportion, population standard deviation Sample Statistics (or simply Statistics) summarize data from a sample; Example: Sample mean, Sample proportion, Sample standard deviation Estimate A sample statistic used to estimate an unknown population parameter Sampling distribution which is the probability distribution of a sample statistic. Random Experiment Procedure or an operation whose outcome is uncertain and cannot be predicted in advance. Sample Space The collection of all possible outcomes of a random experiment events – Set of outcomes of a random experiment probability distribution A probability distribution is a formula or a table used to assign probabilities to each possible value of a random variable X. A probability distribution may be either discrete or continuous. A discrete distribution means that X can assume one of a countable (usually finite) number of values, while a continuous distribution means that X can assume one of an infinite (uncountable) number of different values.","categories":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"}],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"}]},{"title":"The common used commands in Hexo","slug":"hexo-commands","date":"2020-05-30T06:31:32.000Z","updated":"2020-07-27T18:50:34.985Z","comments":true,"path":"en/hexo-commands/","link":"","permalink":"http://haiming2048.github.io/en/hexo-commands/","excerpt":"","text":"The common used hexo’s command1. Create a new article $ hexo new [layout] &lt;title&gt; If no layout provided, Hexo will use the default_layout from _config.yml Such as hexo new test, will create a new article nameed as test 2. Generate $ hexo generate or hexo g Genarate static files, then you can find the output files in public folder 3. Server $ hexo server or hexo s Starts a local server. By default, this is at http://localhost:4000/ 4. Deploy $ hexo deploy or hexo d Deploys your web site, you can deploy your web on github pages, check this links for more information. https://hexo.io/docs/github-pages 5. clean $ hexo clean Cleans the cache file(db.json) and generated files(piblic). Those above commands are common used in hexo when we try to write a new article or try to deploy our web page on github. Besides, there are some other commands you may need to use sometimes, but not very often.Such as: $ hexo publish [layout] &lt;filename&gt; Publishes a draft $ hexo migrate &lt;type&gt; Migrates content from other blog systems. $ hexo list &lt;type&gt; Lists all routes $ hexo version Displays version information $ hexo --cwd /path/to/cwd Customizes the path of current working directory. $ hexo --draft Displays draft posts (stored in the source/_drafts folder).","categories":[],"tags":[]},{"title":"Data Science","slug":"data_science","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-06T03:22:25.942Z","comments":true,"path":"en/data_science/","link":"","permalink":"http://haiming2048.github.io/en/data_science/","excerpt":"","text":"This article is about Data science notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"}]},{"title":"Machine Learning","slug":"python_ML","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T00:46:18.693Z","comments":true,"path":"en/python_ML/","link":"","permalink":"http://haiming2048.github.io/en/python_ML/","excerpt":"","text":"This article is about Machine Learning notes, coming soon!","categories":[{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/categories/ML/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/tags/ML/"}]},{"title":"Python Pandas","slug":"python_pandas","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T02:35:42.863Z","comments":true,"path":"en/python_pandas/","link":"","permalink":"http://haiming2048.github.io/en/python_pandas/","excerpt":"","text":"This article is about python pandas library notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Pandas","slug":"Data-Science/Pandas","permalink":"http://haiming2048.github.io/categories/Data-Science/Pandas/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Pandas","slug":"Pandas","permalink":"http://haiming2048.github.io/tags/Pandas/"}]},{"title":"Python Plots","slug":"python_plot","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T02:46:13.026Z","comments":true,"path":"en/python_plot/","link":"","permalink":"http://haiming2048.github.io/en/python_plot/","excerpt":"","text":"This article is about python Plots(include: matplot, seaborn, plotly) library notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Plot","slug":"Data-Science/Plot","permalink":"http://haiming2048.github.io/categories/Data-Science/Plot/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Plot","slug":"Plot","permalink":"http://haiming2048.github.io/tags/Plot/"}]}],"categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/categories/Sql/"},{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/categories/Statistics/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://haiming2048.github.io/categories/Algorithm/"},{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/categories/ML/"},{"name":"Pandas","slug":"Data-Science/Pandas","permalink":"http://haiming2048.github.io/categories/Data-Science/Pandas/"},{"name":"Plot","slug":"Data-Science/Plot","permalink":"http://haiming2048.github.io/categories/Data-Science/Plot/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Python","slug":"Python","permalink":"http://haiming2048.github.io/tags/Python/"},{"name":"Sql","slug":"Sql","permalink":"http://haiming2048.github.io/tags/Sql/"},{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"Probability","slug":"Probability","permalink":"http://haiming2048.github.io/tags/Probability/"},{"name":"P-value","slug":"P-value","permalink":"http://haiming2048.github.io/tags/P-value/"},{"name":"Binary Searach","slug":"Binary-Searach","permalink":"http://haiming2048.github.io/tags/Binary-Searach/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://haiming2048.github.io/tags/Leetcode/"},{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/tags/ML/"},{"name":"Pandas","slug":"Pandas","permalink":"http://haiming2048.github.io/tags/Pandas/"},{"name":"Plot","slug":"Plot","permalink":"http://haiming2048.github.io/tags/Plot/"}]}