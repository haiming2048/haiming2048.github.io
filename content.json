{"meta":{"title":"Haiming","subtitle":"Hacker inside","description":"description....","author":"Haiming","url":"http://haiming2048.github.io","root":"/"},"pages":[],"posts":[{"title":"Binary Search Summary","slug":"Binary_search_summary","date":"2020-06-25T15:34:55.000Z","updated":"2020-06-25T18:21:13.553Z","comments":true,"path":"en/Binary_search_summary/","link":"","permalink":"http://haiming2048.github.io/en/Binary_search_summary/","excerpt":"","text":"How Binary Search workBinary Search operates on a contiguous sequence with a specified left and right index. This is called the Search Space.Binary Search maintains the left, right, and middle indicies of the search space and compares the search target or applies the search condition to the middle value of the collection; if the condition is unsatisfied or values unequal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful. If the search ends with an empty half, the condition cannot be fulfilled and target is not found. NoteBinary Search can take many alternate forms and might not always be as straight forward as searching for a specific value. Sometimes you will have to apply a specific condition or rule to determine which side (left or right) to search next. TemplatesBasically, there are three templates we will often use in Binary Search, I will introduce them latter. How do we identify Binary Search?As mentioned in earlier, Binary Search is an algorithm that divides the search space in 2 after every comparison. Binary Search should be considered every time you need to search for an index or element in a collection. If the collection is unordered, we can always sort it first before applying Binary Search. 3 Parts of a Successful Binary SearchBinary Search is generally composed of 3 main sections:1. Pre-processing - Sort if collection is unsorted.2. Binary Search - Using a loop or recursion to divide search space in half after each comparison.3. Post-processing - Determine viable candidates in the remaining space. Binary Search Template I123456789101112131415161718192021def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 # End Condition: left &gt; right return -1 Template #1 is the most basic and elementary form of Binary Search. It is the standard Binary Search Template that most high schools or universities use when they first teach students computer science.Template #1 is used to search for an element or condition which can be determined by accessing a single index in the array. Key Attributes: An advanced way to implement Binary Search. Search Condition needs to access element’s immediate right neighbor Use element’s right neighbor to determine if condition is met and decide whether to go left or right Gurantees Search Space is at least 2 in size at each step Post-processing required. Loop/Recursion ends when you have 1 element left. Need to assess if the remaining element meets the condition. Distinguishing Syntax: Initial Condition: left = 0, right = length Termination: left == right Searching Left: right = mid Searching Right: left = mid+1 Template #1 Example Leetcode: #69. Sqrt(x)123456789101112131415161718192021222324252627282930313233'''Leetcode: #69. Sqrt(x)Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.Example 1:Input: 4Output: 2Example 2:Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.'''# Binary Search solotionclass Solution: def mySqrt(self, x: int) -&gt; int: left = 0 right = x while left &lt;= right: mid = left + (right - left) // 2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right Other simily questions using this template: Leetcode(#33, #374) Binary Search Template II123456789101112131415161718192021222324def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) while left &lt; right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid # Post-processing: # End Condition: left == right if left != len(nums) and nums[left] == target: return left return -1 Template #2 is an advanced form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate right neighbor’s index in the array. Key Attributes: Most basic and elementary form of Binary Search Search Condition can be determined without comparing to the element’s neighbors (or use specific elements around it) No post-processing required because at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found Distinguishing Syntax: Initial Condition: left = 0, right = length-1 Termination: left &gt; right Searching Left: right = mid-1 Searching Right: left = mid+1 Template #2 Example Leetcode: #278. First Bad Version123456789101112131415161718192021222324252627282930313233343536'''Leetcode: #278. First Bad VersionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.Example:Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. '''# Binary Search solotionclass Solution: def firstBadVersion(self, n): left = 1 right = n while left &lt; right: mid = (left + right ) //2 if isBadVersion(mid): right = mid else: left = mid + 1 return left Other simily questions using this template: Leetcode(#153, #162) Binary Search Template III123456789101112131415161718192021222324def binarySearch(nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" if len(nums) == 0: return -1 left, right = 0, len(nums) while left &lt; right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] &lt; target: left = mid + 1 else: right = mid # Post-processing: # End Condition: left == right if left != len(nums) and nums[left] == target: return left return -1 Template #3 is another unique form of Binary Search. It is used to search for an element or condition which requires accessing the current index and its immediate left and right neighbor’s index in the array. Key Attributes: An alternative way to implement Binary Search Search Condition needs to access element’s immediate left and right neighbors Use element’s neighbors to determine if condition is met and decide whether to go left or right Gurantees Search Space is at least 3 in size at each step Post-processing required. Loop/Recursion ends when you have 2 elements left. Need to assess if the remaining elements meet the condition. Distinguishing Syntax: Initial Condition: left = 0, right = length-1 Termination: left + 1 == right Searching Left: right = mid Searching Right: left = mid Template #3 Example Leetcode: #34. Find First and Last Position of Element in Sorted Array 1234567891011121314151617181920212223242526272829303132333435'''Leetcode: #34. Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm's runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].Example 1:Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Example 2:Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]'''# Binary Search solotionclass Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: if not nums: return [-1,-1] def lower(data, target): l,r = 0,len(data) while l &lt; r: mid = (l+r)//2 if target &gt; data[mid]: l = mid + 1 else: r = mid return l left = lower(nums, target) right = lower(nums, target+1)-1 return [left, right] if left &lt; len(nums) and nums[left]==target else [-1,-1] Other simily questions using this template: Leetcode(#162, #658) reference:Leetcode: https://leetcode.com/explore/learn/card/binary-search","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://haiming2048.github.io/categories/Algorithm/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://haiming2048.github.io/tags/Leetcode/"},{"name":"Binary Searach","slug":"Binary-Searach","permalink":"http://haiming2048.github.io/tags/Binary-Searach/"}]},{"title":"Statistics Notation","slug":"statistics_Notation","date":"2020-06-01T00:34:25.000Z","updated":"2020-06-21T02:46:01.475Z","comments":true,"path":"en/statistics_Notation/","link":"","permalink":"http://haiming2048.github.io/en/statistics_Notation/","excerpt":"","text":"What is Statistics it is the science of collecting, summarizing, presenting and analyzing data from the purpose of drawing conclusions and making decisions the common used notations in statistics:Population &amp; Sample Population is a collection of all units of interest(may be people, households, geographic regions items produced ets). A sample is a subset of population from which the data is collected Parameter A numerical characteristic of a population defined for a specific variable (Examples: Population mean, population proportion etc.) Variables We are interested in one or more measurable properties or attributes associated with each unit in the population. These properties are called variables. Population Parameters(or simply Parameters) summarize data for an entire population; Example: Population mean, Population proportion, population standard deviation Sample Statistics (or simply Statistics) summarize data from a sample; Example: Sample mean, Sample proportion, Sample standard deviation Estimate A sample statistic used to estimate an unknown population parameter Sampling distribution which is the probability distribution of a sample statistic. Random Experiment Procedure or an operation whose outcome is uncertain and cannot be predicted in advance. Sample Space The collection of all possible outcomes of a random experiment events – Set of outcomes of a random experiment probability distribution A probability distribution is a formula or a table used to assign probabilities to each possible value of a random variable X. A probability distribution may be either discrete or continuous. A discrete distribution means that X can assume one of a countable (usually finite) number of values, while a continuous distribution means that X can assume one of an infinite (uncountable) number of different values.","categories":[],"tags":[{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"}]},{"title":"The common used commands in Hexo","slug":"hexo-commands","date":"2020-05-30T06:31:32.000Z","updated":"2020-06-21T02:35:27.031Z","comments":true,"path":"en/hexo-commands/","link":"","permalink":"http://haiming2048.github.io/en/hexo-commands/","excerpt":"","text":"The common used hexo’s command1. Create a new article $ hexo new [layout] &lt;title&gt; If no layout provided, Hexo will use the default_layout from _config.yml Such as hexo new test, will create a new article nameed as test 2. Generate $ hexo generate or hexo g Genarate static files, then you can find the output files in public folder 3. Server $ hexo server or hexo s Starts a local server. By default, this is at http://localhost:4000/ 4. Deploy $ hexo deploy or hexo d Deploys your web site, you can deploy your web on github pages, check this links for more information. https://hexo.io/docs/github-pages 5. clean $ hexo clean Cleans the cache file(db.json) and generated files(piblic). Those above commands are common used in hexo when we try to write a new article or try to deploy our web page on github. Besides, there are some other commands you may need to use sometimes, but not very often.Such as: $ hexo publish [layout] &lt;filename&gt; Publishes a draft $ hexo migrate &lt;type&gt; Migrates content from other blog systems. $ hexo list &lt;type&gt; Lists all routes $ hexo version Displays version information $ hexo --cwd /path/to/cwd Customizes the path of current working directory. $ hexo --draft Displays draft posts (stored in the source/_drafts folder).","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://haiming2048.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://haiming2048.github.io/tags/Hexo/"}]},{"title":"Data Science","slug":"data_science","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-06T03:22:25.942Z","comments":true,"path":"en/data_science/","link":"","permalink":"http://haiming2048.github.io/en/data_science/","excerpt":"","text":"This article is about Data science notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"}]},{"title":"Machine Learning","slug":"python_ML","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T00:46:18.693Z","comments":true,"path":"en/python_ML/","link":"","permalink":"http://haiming2048.github.io/en/python_ML/","excerpt":"","text":"This article is about Machine Learning notes, coming soon!","categories":[{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/categories/ML/"}],"tags":[{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/tags/ML/"}]},{"title":"Python Pandas","slug":"python_pandas","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T02:35:42.863Z","comments":true,"path":"en/python_pandas/","link":"","permalink":"http://haiming2048.github.io/en/python_pandas/","excerpt":"","text":"This article is about python pandas library notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Pandas","slug":"Data-Science/Pandas","permalink":"http://haiming2048.github.io/categories/Data-Science/Pandas/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Pandas","slug":"Pandas","permalink":"http://haiming2048.github.io/tags/Pandas/"}]},{"title":"Python Plots","slug":"python_plot","date":"2020-04-10T19:56:22.000Z","updated":"2020-06-21T02:46:13.026Z","comments":true,"path":"en/python_plot/","link":"","permalink":"http://haiming2048.github.io/en/python_plot/","excerpt":"","text":"This article is about python Plots(include: matplot, seaborn, plotly) library notes, coming soon!","categories":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"Plot","slug":"Data-Science/Plot","permalink":"http://haiming2048.github.io/categories/Data-Science/Plot/"}],"tags":[{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"Plot","slug":"Plot","permalink":"http://haiming2048.github.io/tags/Plot/"}]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://haiming2048.github.io/categories/Algorithm/"},{"name":"Hexo","slug":"Hexo","permalink":"http://haiming2048.github.io/categories/Hexo/"},{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/categories/Data-Science/"},{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/categories/ML/"},{"name":"Pandas","slug":"Data-Science/Pandas","permalink":"http://haiming2048.github.io/categories/Data-Science/Pandas/"},{"name":"Plot","slug":"Data-Science/Plot","permalink":"http://haiming2048.github.io/categories/Data-Science/Plot/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://haiming2048.github.io/tags/Leetcode/"},{"name":"Binary Searach","slug":"Binary-Searach","permalink":"http://haiming2048.github.io/tags/Binary-Searach/"},{"name":"Statistics","slug":"Statistics","permalink":"http://haiming2048.github.io/tags/Statistics/"},{"name":"Hexo","slug":"Hexo","permalink":"http://haiming2048.github.io/tags/Hexo/"},{"name":"Data Science","slug":"Data-Science","permalink":"http://haiming2048.github.io/tags/Data-Science/"},{"name":"ML","slug":"ML","permalink":"http://haiming2048.github.io/tags/ML/"},{"name":"Pandas","slug":"Pandas","permalink":"http://haiming2048.github.io/tags/Pandas/"},{"name":"Plot","slug":"Plot","permalink":"http://haiming2048.github.io/tags/Plot/"}]}